// Generated by IcedCoffeeScript 1.8.0-d
(function() {
  define(function() {
    var StateMenager;
    return StateMenager = (function() {
      var StateFactory, _parseNested, _stateFactory;

      StateFactory = (function() {
        var NestedStateLoader, StateLoader;

        function StateFactory() {}

        StateLoader = (function() {
          function StateLoader(path) {
            var deferred;
            deferred = $.Deferred();
            require([path], (function(_this) {
              return function(View) {
                return setTimeout(function() {
                  return deferred.resolve(View);
                }, 0);
              };
            })(this));
            this.promise = deferred.promise();
          }

          return StateLoader;

        })();

        NestedStateLoader = (function() {
          function NestedStateLoader(path, parent) {
            var deferred;
            deferred = $.Deferred();
            require([path], (function(_this) {
              return function(View) {
                return setTimeout(function() {
                  return parent.promise.then(function() {
                    return deferred.resolve(View);
                  });
                }, path === "page/product/list/view" ? 0 : 0);
              };
            })(this));
            this.promise = deferred.promise();
          }

          return NestedStateLoader;

        })();

        StateFactory.prototype.create = function(name, parent) {
          if (!parent) {
            return new StateLoader(name);
          } else {
            return new NestedStateLoader(name, parent);
          }
        };

        return StateFactory;

      })();

      _stateFactory = new StateFactory;

      _parseNested = function(fullname) {
        var current, name, names, _i, _len, _results;
        names = fullname.split(".");
        current = [];
        _results = [];
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          name = names[_i];
          current.push(name);
          _results.push(current.join("."));
        }
        return _results;
      };

      function StateMenager(config) {
        this.config = config;
        this.cache = {};
        this.selector = {};
      }

      StateMenager.prototype.load = function(setting) {
        var last, names, param, state, stateName, _i, _len, _ref, _results;
        names = _parseNested(setting.state);
        param = setting.param;
        last = null;
        for (_i = 0, _len = names.length; _i < _len; _i++) {
          stateName = names[_i];
          if (stateName) {
            (function(_this) {
              return (function(stateName, current, currentConfig) {
                var animationState, currentPriorityHorisontal, currentPriorityVertical, pre, preConfig, prePriorityHorisontal, prePriorityVertical, preStateName;
                if (!(currentConfig && _this.selector[currentConfig.selector]) && !(current && current.view)) {
                  last = current = _this.cache[stateName] = _stateFactory.create(currentConfig.path, last);
                  current.promise.then(function(ViewInstance) {
                    current.view = currentConfig.init(ViewInstance, (param ? param[stateName] : void 0));
                    currentConfig.animation.first(current.view);
                    return current.status = "first";
                  });
                  return _this.selector[currentConfig.selector] = stateName;
                } else if (_this.selector[currentConfig.selector] && _this.selector[currentConfig.selector] !== stateName) {
                  preStateName = _this.selector[currentConfig.selector];
                  pre = _this.cache[preStateName];
                  preConfig = _this.config.routes[preStateName];
                  prePriorityVertical = preConfig.priority[0];
                  prePriorityHorisontal = preConfig.priority[1];
                  currentPriorityVertical = currentConfig.priority[0];
                  currentPriorityHorisontal = currentConfig.priority[1];
                  if (prePriorityVertical < currentPriorityVertical) {
                    animationState = "bottom-top";
                  } else if (prePriorityVertical > currentPriorityVertical) {
                    animationState = "top-bottom";
                  } else if (prePriorityVertical === currentPriorityVertical) {
                    if (prePriorityHorisontal < currentPriorityHorisontal) {
                      animationState = "left-right";
                    } else if (prePriorityHorisontal > currentPriorityHorisontal) {
                      animationState = "right-left";
                    }
                  }
                  switch (animationState) {
                    case "bottom-top":
                      preConfig.animation.centerTop(pre.view, preConfig.last);
                      break;
                    case "top-bottom":
                      preConfig.animation.centerBottom(pre.view, preConfig.last);
                      break;
                    case "left-right":
                      preConfig.animation.centerRight(pre.view, preConfig.last);
                      break;
                    case "right-left":
                      preConfig.animation.centerLeft(pre.view, preConfig.last);
                  }
                  pre = null;
                  last = current = _this.cache[stateName] = _stateFactory.create(currentConfig.path, last);
                  current.promise.then(function(ViewInstance) {
                    current.view = currentConfig.init(ViewInstance, (param ? param[stateName] : void 0));
                    switch (animationState) {
                      case "bottom-top":
                        currentConfig.animation.bottomCenter(current.view, currentConfig.first);
                        break;
                      case "top-bottom":
                        currentConfig.animation.topCenter(current.view, currentConfig.first);
                        break;
                      case "left-right":
                        currentConfig.animation.leftCenter(current.view, currentConfig.first);
                        break;
                      case "right-left":
                        currentConfig.animation.rightCenter(current.view, currentConfig.first);
                    }
                    return current.status = "show";
                  });
                  return _this.selector[currentConfig.selector] = stateName;
                }
              });
            })(this)(stateName, this.cache[stateName], this.config.routes[stateName]);
          }
        }
        _ref = this.config.routes;
        _results = [];
        for (stateName in _ref) {
          state = _ref[stateName];
          if (names.indexOf(stateName) === -1) {
            _results.push((function(_this) {
              return function(stateName, current, currentConfig) {
                var selectorName;
                selectorName = _this.selector[currentConfig.selector];
                if (current && current.view && selectorName && selectorName === stateName) {
                  currentConfig.animation.last(current.view);
                  current.view = null;
                  _this.selector[currentConfig.selector] = null;
                  return current.status = "last";
                }
              };
            })(this)(stateName, this.cache[stateName], this.config.routes[stateName]));
          }
        }
        return _results;
      };

      return StateMenager;

    })();
  });

}).call(this);
